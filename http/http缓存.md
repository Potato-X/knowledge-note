# HTTP缓存

## HTTP缓存分为强制缓存和协商缓存

### 强制缓存

强制缓存顾名思义就是不走服务器，直接通过浏览器去拿缓存，在向后台请求资源的时候，浏览器自己会把服务器返回的资源缓存一份，如果开了强制缓存后，则下次再请求资源的时候，就直接向浏览器拿之前的缓存资源

#### Expires

在http1.0规范里，通过设置请求头expires这个字段来控制浏览器缓存的有效时间，expires这个字段本身表示的意思是服务端返回的过期时间，如果请求发出后，请求的本地时间小于这个服务器返回的到期时间（expires），则采用浏览器缓存的资源，否则就视为缓存失效了，需要重新请求服务器获取资源，浏览器也需要重新缓存请求的资源；

缺点:使用expires判断是否缓存失效是通过客户端的本地时间与服务器返回的到期时间进行比较的，可能会存在服务器的时间与客户端的本地时间不一样，比如客户端本地时间会比服务器的时间快个几分钟或者慢个几分钟，则就导致同一份资源可能在不同客户端的浏览器的缓存时间间隔就不同，存在误差

解决方法：为了规避上诉使用expires这个字段来判断是否缓存有效这个方法所存在的缺点，于是http1.1规范里就新出了一个cache-control这个请求头字段

#### Cache-control

Cache-control常见的属性值如下所示

|属性   |值  |备注|
-------|----|-----
max-age|3600|例如值为3600，表示（当前时间+3600秒）内不与服务器请求新的数据资源
s-maxage|    |和max-age一样，但这个是设定代理服务器的缓存时间
private|    |仅客户端的浏览器可以换成，代理服务器不能换成资源
public|     |客户端的浏览器和代理服务器都可以缓存请求的资源
no-store|   |不缓存任何数据，每次都是重新向服务器请求最新的资源
no-cache|   |设置为此值后，客户端浏览器的是否采用缓存资源将通过服务器判断后返回决定（即协商缓存）

ps:当请求头同时设置了Expires和Cache-control这两个字段过后，Cache-control优先级最高，优先通过Cache-control这个字段来判断浏览器的缓存状态

### 协商缓存（对比缓存）

协商缓存顾名思义就是浏览器客户端通过与服务器共同协商来决定客户端是否采用缓存资源，em，有点晦涩
实际上就是服务器对前后客户端请求的资源是否发生了更新来判断是否客户端应该采用缓存资源，如果客户端请求的资源对比之前的缓存资源已经发生了更新，则客户端则会向服务端请求最新的资源，如果客户端请求的资源对比之前的缓存资源并未发生更新修改，则服务器判定客户端可以继续采用缓存的资源进行展示处理

这里提到了检测请求的资源是否发生更新修改，那这里采用的是什么方法呢？
最开始采用的是设置请求头Last-modified这个字段来判断
Last-modified：表示的是本地文件最后一次修改更新的时间，由服务端返回
与Last-modified对应的字段是if-modified-since：是在浏览器请求数据的时候返回的，它的值表示的是客户端上一次更新的时间（Last-modified）

这里通过请求资源的更新时间前后是否一致来判断客户端页面请求资源的时候是否该采用缓存，这里有个小问题————当请求的资源比如某个文件，当这个文件被请求到后，客户端先修改一次然后又修改回去，虽然文件的内容没有发生变化，但是却会导致文件的修改时间被更新，即Last-modified这个字段会发生改变，那么在请求的时候，Last-modified与if-modified-since返回的上一次的Last-modified的值就不一致了，从而导致客户端会重新向服务端请求资源

为了解决这个问题，引出了另一对请求头字段（ETag和if-none-match）
ETag：一个文件的唯一标识符，当资源发生变化时这个ETag就会发生变化。
if-none-match：浏览器请求数据时带上的字段，值是上次服务器返回的ETag
这样通过对比唯一标识符来判断当前文件的内容是否发生了修改就比之前通过修改更新时间这样的方法可靠的多了，因为ETag是只要你的文件内容发生修改，就会生成一个唯一的标识符

#### 缓存的流程：

1.当浏览器发起一个资源请求时，浏览器会先判断本地是否有缓存记录，如果没有会向浏览器请求新的资源，并记录服务器返回的last-modified。

2.如果有缓存记录，先判断强缓存是否存在（cache-control优先于expires，后面会说），如果强缓存的时间没有过期则返回本地缓存资源（状态码为200）

3.如果强缓存失效了，客户端会发起请求进行协商缓存策略，首先服务器判断Etag标识符，如果客户端传来标识符和当前服务器上的标识符是一致的，则返回状态码 304 not modified（不会返回资源内容）

4.如果没有Etag字段，服务器会对比客户端传过来的if-modified-match，如果这两个值是一致的，此时响应头不会带有last-modified字段（因为资源没有变化，5.last-modified的值也不会有变化）。客户端304状态码之后读取本地缓存。如果last-modified。

5.如果Etag和服务器端上的不一致，重新获取新的资源，并进行协商缓存返回数据。

#### 为什么需要ETag
1.它的出现主要是解决last-modified几个比较难以解决的问题

2.在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求
可能有些文件修改比较频繁，秒级以内修改的，If-Modified-Since 能检查到的粒度是秒级的，使用 Etag 就能够保证这种需求下客户端在 1 秒内能刷新多次。

3.有些服务器不能精确获取文件的最后修改时间

#### 采用缓存后，http返回的响应状态码含义
200 请求成功:服务器直接返回最新的数据
200 from memory cache/from disk cache:使用本地强缓存
304 请求成功：强缓存失效，走协商缓存

ps:
*1.from memory cache意思是浏览器当前这个tab页签没关闭的情况下，如果刷新页面的话，那么请求的资源是从浏览器的内存里面取的
*2.from disk cache意思是浏览器当前这个页签如果关闭了，则从磁盘里面取
3.缓存优先级，强缓存>协商缓存





